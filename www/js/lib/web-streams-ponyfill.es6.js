!function(global,factory){"object"==typeof exports&&"undefined"!=typeof module?factory(exports):"function"==typeof define&&define.amd?define(["exports"],factory):factory((global="undefined"!=typeof globalThis?globalThis:global||self).WebStreamsPolyfill={})}(this,function(exports){"use strict";var SymbolPolyfill="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?Symbol:description=>`Symbol(${description})`;function noop(){}var globals="undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:void 0;function typeIsObject(x){return"object"==typeof x&&null!==x||"function"==typeof x}var rethrowAssertionErrorRejection=noop,originalPromise=Promise,originalPromiseThen=Promise.prototype.then,originalPromiseResolve=Promise.resolve.bind(originalPromise),originalPromiseReject=Promise.reject.bind(originalPromise);function newPromise(executor){return new originalPromise(executor)}function promiseResolvedWith(value){return originalPromiseResolve(value)}function promiseRejectedWith(reason){return originalPromiseReject(reason)}function PerformPromiseThen(promise,onFulfilled,onRejected){return originalPromiseThen.call(promise,onFulfilled,onRejected)}function uponPromise(promise,onFulfilled,onRejected){PerformPromiseThen(PerformPromiseThen(promise,onFulfilled,onRejected),void 0,rethrowAssertionErrorRejection)}function uponFulfillment(promise,onFulfilled){uponPromise(promise,onFulfilled)}function uponRejection(promise,onRejected){uponPromise(promise,void 0,onRejected)}function transformPromiseWith(promise,fulfillmentHandler,rejectionHandler){return PerformPromiseThen(promise,fulfillmentHandler,rejectionHandler)}function setPromiseIsHandledToTrue(promise){PerformPromiseThen(promise,void 0,rethrowAssertionErrorRejection)}var resolvedPromise,queueMicrotask="function"==typeof(globals=globals&&globals.queueMicrotask)?globals:(resolvedPromise=promiseResolvedWith(void 0),fn=>PerformPromiseThen(resolvedPromise,fn));function reflectCall(F,V,args){if("function"!=typeof F)throw new TypeError("Argument is not a function");return Function.prototype.apply.call(F,V,args)}function promiseCall(F,V,args){try{return promiseResolvedWith(reflectCall(F,V,args))}catch(value){return promiseRejectedWith(value)}}class SimpleQueue{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0}get length(){return this._size}push(element){var oldBack=this._back,newBack=oldBack;16383===oldBack._elements.length&&(newBack={_elements:[],_next:void 0}),oldBack._elements.push(element),newBack!==oldBack&&(this._back=newBack,oldBack._next=newBack),++this._size}shift(){var oldFront=this._front,newFront=oldFront,oldCursor=this._cursor,newCursor=oldCursor+1,elements=oldFront._elements,element=elements[oldCursor];return 16384===newCursor&&(newFront=oldFront._next,newCursor=0),--this._size,this._cursor=newCursor,oldFront!==newFront&&(this._front=newFront),elements[oldCursor]=void 0,element}forEach(callback){for(var i=this._cursor,node=this._front,elements=node._elements;!(i===elements.length&&void 0===node._next||i===elements.length&&(i=0)===(elements=(node=node._next)._elements).length);)callback(elements[i]),++i}peek(){var front=this._front,cursor=this._cursor;return front._elements[cursor]}}function ReadableStreamReaderGenericInitialize(reader,stream){(reader._ownerReadableStream=stream)._reader=reader,"readable"===stream._state?defaultReaderClosedPromiseInitialize(reader):"closed"===stream._state?function(reader){defaultReaderClosedPromiseInitialize(reader),defaultReaderClosedPromiseResolve(reader)}(reader):defaultReaderClosedPromiseInitializeAsRejected(reader,stream._storedError)}function ReadableStreamReaderGenericCancel(reader,reason){return ReadableStreamCancel(reader._ownerReadableStream,reason)}function ReadableStreamReaderGenericRelease(reader){("readable"===reader._ownerReadableStream._state?defaultReaderClosedPromiseReject:function(reader,reason){defaultReaderClosedPromiseInitializeAsRejected(reader,reason)})(reader,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),reader._ownerReadableStream._reader=void 0,reader._ownerReadableStream=void 0}function readerLockException(name){return new TypeError("Cannot "+name+" a stream using a released reader")}function defaultReaderClosedPromiseInitialize(reader){reader._closedPromise=newPromise((resolve,reject)=>{reader._closedPromise_resolve=resolve,reader._closedPromise_reject=reject})}function defaultReaderClosedPromiseInitializeAsRejected(reader,reason){defaultReaderClosedPromiseInitialize(reader),defaultReaderClosedPromiseReject(reader,reason)}function defaultReaderClosedPromiseReject(reader,reason){void 0!==reader._closedPromise_reject&&(setPromiseIsHandledToTrue(reader._closedPromise),reader._closedPromise_reject(reason),reader._closedPromise_resolve=void 0,reader._closedPromise_reject=void 0)}function defaultReaderClosedPromiseResolve(reader){void 0!==reader._closedPromise_resolve&&(reader._closedPromise_resolve(void 0),reader._closedPromise_resolve=void 0,reader._closedPromise_reject=void 0)}var AsyncIteratorPrototype,AbortSteps=SymbolPolyfill("[[AbortSteps]]"),ErrorSteps=SymbolPolyfill("[[ErrorSteps]]"),CancelSteps=SymbolPolyfill("[[CancelSteps]]"),PullSteps=SymbolPolyfill("[[PullSteps]]"),NumberIsFinite=Number.isFinite||function(x){return"number"==typeof x&&isFinite(x)},MathTrunc=Math.trunc||function(v){return v<0?Math.ceil(v):Math.floor(v)};function assertDictionary(obj,context){if(void 0!==obj&&"object"!=typeof(obj=obj)&&"function"!=typeof obj)throw new TypeError(context+" is not an object.")}function assertFunction(x,context){if("function"!=typeof x)throw new TypeError(context+" is not a function.")}function assertObject(x,context){if(!function(x){return"object"==typeof x&&null!==x||"function"==typeof x}(x))throw new TypeError(context+" is not an object.")}function assertRequiredArgument(x,position,context){if(void 0===x)throw new TypeError(`Parameter ${position} is required in '${context}'.`)}function assertRequiredField(x,field,context){if(void 0===x)throw new TypeError(field+` is required in '${context}'.`)}function convertUnrestrictedDouble(value){return Number(value)}function censorNegativeZero(x){return 0===x?0:x}function convertUnsignedLongLongWithEnforceRange(value,context){var upperBound=Number.MAX_SAFE_INTEGER,value=censorNegativeZero(Number(value));if(!NumberIsFinite(value))throw new TypeError(context+" is not a finite number");if((value=function(x){return censorNegativeZero(MathTrunc(x))}(value))<0||upperBound<value)throw new TypeError(context+` is outside the accepted range of 0 to ${upperBound}, inclusive`);return NumberIsFinite(value)&&0!==value?value:0}function assertReadableStream(x,context){if(!IsReadableStream(x))throw new TypeError(context+" is not a ReadableStream.")}function AcquireReadableStreamDefaultReader(stream){return new ReadableStreamDefaultReader(stream)}function ReadableStreamAddReadRequest(stream,readRequest){stream._reader._readRequests.push(readRequest)}function ReadableStreamFulfillReadRequest(stream,chunk,done){stream=stream._reader._readRequests.shift();done?stream._closeSteps():stream._chunkSteps(chunk)}function ReadableStreamHasDefaultReader(stream){stream=stream._reader;return void 0!==stream&&!!IsReadableStreamDefaultReader(stream)}class ReadableStreamDefaultReader{constructor(stream){if(assertRequiredArgument(stream,1,"ReadableStreamDefaultReader"),assertReadableStream(stream,"First parameter"),IsReadableStreamLocked(stream))throw new TypeError("This stream has already been locked for exclusive reading by another reader");ReadableStreamReaderGenericInitialize(this,stream),this._readRequests=new SimpleQueue}get closed(){return IsReadableStreamDefaultReader(this)?this._closedPromise:promiseRejectedWith(defaultReaderBrandCheckException("closed"))}cancel(reason=void 0){return IsReadableStreamDefaultReader(this)?void 0===this._ownerReadableStream?promiseRejectedWith(readerLockException("cancel")):ReadableStreamReaderGenericCancel(this,reason):promiseRejectedWith(defaultReaderBrandCheckException("cancel"))}read(){var resolvePromise,rejectPromise,promise;return IsReadableStreamDefaultReader(this)?void 0===this._ownerReadableStream?promiseRejectedWith(readerLockException("read from")):(promise=newPromise((resolve,reject)=>{resolvePromise=resolve,rejectPromise=reject}),ReadableStreamDefaultReaderRead(this,{_chunkSteps:chunk=>resolvePromise({value:chunk,done:!1}),_closeSteps:()=>resolvePromise({value:void 0,done:!0}),_errorSteps:e=>rejectPromise(e)}),promise):promiseRejectedWith(defaultReaderBrandCheckException("read"))}releaseLock(){if(!IsReadableStreamDefaultReader(this))throw defaultReaderBrandCheckException("releaseLock");if(void 0!==this._ownerReadableStream){if(0<this._readRequests.length)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");ReadableStreamReaderGenericRelease(this)}}}function IsReadableStreamDefaultReader(x){return typeIsObject(x)&&Object.prototype.hasOwnProperty.call(x,"_readRequests")&&x instanceof ReadableStreamDefaultReader}function ReadableStreamDefaultReaderRead(reader,readRequest){reader=reader._ownerReadableStream;reader._disturbed=!0,"closed"===reader._state?readRequest._closeSteps():"errored"===reader._state?readRequest._errorSteps(reader._storedError):reader._readableStreamController[PullSteps](readRequest)}function defaultReaderBrandCheckException(name){return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`)}Object.defineProperties(ReadableStreamDefaultReader.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),"symbol"==typeof SymbolPolyfill.toStringTag&&Object.defineProperty(ReadableStreamDefaultReader.prototype,SymbolPolyfill.toStringTag,{value:"ReadableStreamDefaultReader",configurable:!0}),"symbol"==typeof SymbolPolyfill.asyncIterator&&(AsyncIteratorPrototype={[SymbolPolyfill.asyncIterator](){return this}},Object.defineProperty(AsyncIteratorPrototype,SymbolPolyfill.asyncIterator,{enumerable:!1}));class ReadableStreamAsyncIteratorImpl{constructor(reader,preventCancel){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=reader,this._preventCancel=preventCancel}next(){var nextSteps=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?transformPromiseWith(this._ongoingPromise,nextSteps,nextSteps):nextSteps(),this._ongoingPromise}return(value){var returnSteps=()=>this._returnSteps(value);return this._ongoingPromise?transformPromiseWith(this._ongoingPromise,returnSteps,returnSteps):returnSteps()}_nextSteps(){var reader,resolvePromise,rejectPromise,promise;return this._isFinished?Promise.resolve({value:void 0,done:!0}):void 0===(reader=this._reader)._ownerReadableStream?promiseRejectedWith(readerLockException("iterate")):(promise=newPromise((resolve,reject)=>{resolvePromise=resolve,rejectPromise=reject}),ReadableStreamDefaultReaderRead(reader,{_chunkSteps:chunk=>{this._ongoingPromise=void 0,queueMicrotask(()=>resolvePromise({value:chunk,done:!1}))},_closeSteps:()=>{this._ongoingPromise=void 0,this._isFinished=!0,ReadableStreamReaderGenericRelease(reader),resolvePromise({value:void 0,done:!0})},_errorSteps:reason=>{this._ongoingPromise=void 0,this._isFinished=!0,ReadableStreamReaderGenericRelease(reader),rejectPromise(reason)}}),promise)}_returnSteps(value){if(this._isFinished)return Promise.resolve({value:value,done:!0});this._isFinished=!0;var result,reader=this._reader;return void 0===reader._ownerReadableStream?promiseRejectedWith(readerLockException("finish iterating")):this._preventCancel?(ReadableStreamReaderGenericRelease(reader),promiseResolvedWith({value:value,done:!0})):(result=ReadableStreamReaderGenericCancel(reader,value),ReadableStreamReaderGenericRelease(reader),transformPromiseWith(result,()=>({value:value,done:!0})))}}var ReadableStreamAsyncIteratorPrototype={next(){return IsReadableStreamAsyncIterator(this)?this._asyncIteratorImpl.next():promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"))},return(value){return IsReadableStreamAsyncIterator(this)?this._asyncIteratorImpl.return(value):promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"))}};function IsReadableStreamAsyncIterator(x){if(typeIsObject(x)&&Object.prototype.hasOwnProperty.call(x,"_asyncIteratorImpl"))try{return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl}catch(_a){}}function streamAsyncIteratorBrandCheckException(name){return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`)}void 0!==AsyncIteratorPrototype&&Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype,AsyncIteratorPrototype);var NumberIsNaN=Number.isNaN||function(x){return x!=x};function CopyDataBlockBytes(dest,destOffset,src,srcOffset,n){new Uint8Array(dest).set(new Uint8Array(src,srcOffset,n),destOffset)}function ArrayBufferSlice(buffer,begin,end){var slice;return buffer.slice?buffer.slice(begin,end):(end=end-begin,CopyDataBlockBytes(slice=new ArrayBuffer(end),0,buffer,begin,end),slice)}function CloneAsUint8Array(O){O=ArrayBufferSlice(O.buffer,O.byteOffset,O.byteOffset+O.byteLength);return new Uint8Array(O)}function DequeueValue(container){var pair=container._queue.shift();return container._queueTotalSize-=pair.size,container._queueTotalSize<0&&(container._queueTotalSize=0),pair.value}function EnqueueValueWithSize(container,value,size){if("number"!=typeof(v=size)||(NumberIsNaN(v)||v<0)||size===1/0)throw new RangeError("Size must be a finite, non-NaN, non-negative number.");var v;container._queue.push({value:value,size:size}),container._queueTotalSize+=size}function ResetQueue(container){container._queue=new SimpleQueue,container._queueTotalSize=0}class ReadableStreamBYOBRequest{constructor(){throw new TypeError("Illegal constructor")}get view(){if(IsReadableStreamBYOBRequest(this))return this._view;throw byobRequestBrandCheckException("view")}respond(bytesWritten){if(!IsReadableStreamBYOBRequest(this))throw byobRequestBrandCheckException("respond");if(assertRequiredArgument(bytesWritten,1,"respond"),bytesWritten=convertUnsignedLongLongWithEnforceRange(bytesWritten,"First parameter"),void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");this._view.buffer,ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController,bytesWritten)}respondWithNewView(view){if(!IsReadableStreamBYOBRequest(this))throw byobRequestBrandCheckException("respondWithNewView");if(assertRequiredArgument(view,1,"respondWithNewView"),!ArrayBuffer.isView(view))throw new TypeError("You can only respond with array buffer views");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");view.buffer,ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController,view)}}Object.defineProperties(ReadableStreamBYOBRequest.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),"symbol"==typeof SymbolPolyfill.toStringTag&&Object.defineProperty(ReadableStreamBYOBRequest.prototype,SymbolPolyfill.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:!0});class ReadableByteStreamController{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(IsReadableByteStreamController(this))return ReadableByteStreamControllerGetBYOBRequest(this);throw byteStreamControllerBrandCheckException("byobRequest")}get desiredSize(){if(IsReadableByteStreamController(this))return ReadableByteStreamControllerGetDesiredSize(this);throw byteStreamControllerBrandCheckException("desiredSize")}close(){if(!IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("close");if(this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");var state=this._controlledReadableByteStream._state;if("readable"!==state)throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);ReadableByteStreamControllerClose(this)}enqueue(chunk){if(!IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("enqueue");if(assertRequiredArgument(chunk,1,"enqueue"),!ArrayBuffer.isView(chunk))throw new TypeError("chunk must be an array buffer view");if(0===chunk.byteLength)throw new TypeError("chunk must have non-zero byteLength");if(0===chunk.buffer.byteLength)throw new TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw new TypeError("stream is closed or draining");var state=this._controlledReadableByteStream._state;if("readable"!==state)throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);ReadableByteStreamControllerEnqueue(this,chunk)}error(e=void 0){if(!IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("error");ReadableByteStreamControllerError(this,e)}[CancelSteps](reason){ReadableByteStreamControllerClearPendingPullIntos(this),ResetQueue(this);reason=this._cancelAlgorithm(reason);return ReadableByteStreamControllerClearAlgorithms(this),reason}[PullSteps](readRequest){var stream=this._controlledReadableByteStream;if(0<this._queueTotalSize)entry=this._queue.shift(),this._queueTotalSize-=entry.byteLength,ReadableByteStreamControllerHandleQueueDrain(this),entry=new Uint8Array(entry.buffer,entry.byteOffset,entry.byteLength),readRequest._chunkSteps(entry);else{var entry=this._autoAllocateChunkSize;if(void 0!==entry){try{buffer=new ArrayBuffer(entry)}catch(bufferE){return void readRequest._errorSteps(bufferE)}var buffer={buffer:buffer,bufferByteLength:entry,byteOffset:0,byteLength:entry,bytesFilled:0,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(buffer)}ReadableStreamAddReadRequest(stream,readRequest),ReadableByteStreamControllerCallPullIfNeeded(this)}}}function IsReadableByteStreamController(x){return typeIsObject(x)&&Object.prototype.hasOwnProperty.call(x,"_controlledReadableByteStream")&&x instanceof ReadableByteStreamController}function IsReadableStreamBYOBRequest(x){return typeIsObject(x)&&Object.prototype.hasOwnProperty.call(x,"_associatedReadableByteStreamController")&&x instanceof ReadableStreamBYOBRequest}function ReadableByteStreamControllerCallPullIfNeeded(controller){!function(controller){var stream=controller._controlledReadableByteStream;if("readable"===stream._state&&!controller._closeRequested&&controller._started){if(ReadableStreamHasDefaultReader(stream)&&0<stream._reader._readRequests.length)return!0;if(ReadableStreamHasBYOBReader(stream)&&0<stream._reader._readIntoRequests.length)return!0;if(0<ReadableByteStreamControllerGetDesiredSize(controller))return!0}return!1}(controller)||(controller._pulling?controller._pullAgain=!0:(controller._pulling=!0,uponPromise(controller._pullAlgorithm(),()=>{controller._pulling=!1,controller._pullAgain&&(controller._pullAgain=!1,ReadableByteStreamControllerCallPullIfNeeded(controller))},e=>{ReadableByteStreamControllerError(controller,e)})))}function ReadableByteStreamControllerClearPendingPullIntos(controller){ReadableByteStreamControllerInvalidateBYOBRequest(controller),controller._pendingPullIntos=new SimpleQueue}function ReadableByteStreamControllerCommitPullIntoDescriptor(stream,pullIntoDescriptor){var done=!1,filledView=("closed"===stream._state&&(done=!0),ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor));("default"===pullIntoDescriptor.readerType?ReadableStreamFulfillReadRequest:function(stream,chunk,done){stream=stream._reader._readIntoRequests.shift();done?stream._closeSteps(chunk):stream._chunkSteps(chunk)})(stream,filledView,done)}function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor){var bytesFilled=pullIntoDescriptor.bytesFilled,elementSize=pullIntoDescriptor.elementSize;return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer,pullIntoDescriptor.byteOffset,bytesFilled/elementSize)}function ReadableByteStreamControllerEnqueueChunkToQueue(controller,buffer,byteOffset,byteLength){controller._queue.push({buffer:buffer,byteOffset:byteOffset,byteLength:byteLength}),controller._queueTotalSize+=byteLength}function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller,pullIntoDescriptor){for(var elementSize=pullIntoDescriptor.elementSize,currentAlignedBytes=pullIntoDescriptor.bytesFilled-pullIntoDescriptor.bytesFilled%elementSize,maxBytesToCopy=Math.min(controller._queueTotalSize,pullIntoDescriptor.byteLength-pullIntoDescriptor.bytesFilled),maxBytesFilled=pullIntoDescriptor.bytesFilled+maxBytesToCopy,maxBytesFilled=maxBytesFilled-maxBytesFilled%elementSize,totalBytesToCopyRemaining=maxBytesToCopy,elementSize=!1,queue=(currentAlignedBytes<maxBytesFilled&&(totalBytesToCopyRemaining=maxBytesFilled-pullIntoDescriptor.bytesFilled,elementSize=!0),controller._queue);0<totalBytesToCopyRemaining;){var headOfQueue=queue.peek(),bytesToCopy=Math.min(totalBytesToCopyRemaining,headOfQueue.byteLength),destStart=pullIntoDescriptor.byteOffset+pullIntoDescriptor.bytesFilled;CopyDataBlockBytes(pullIntoDescriptor.buffer,destStart,headOfQueue.buffer,headOfQueue.byteOffset,bytesToCopy),headOfQueue.byteLength===bytesToCopy?queue.shift():(headOfQueue.byteOffset+=bytesToCopy,headOfQueue.byteLength-=bytesToCopy),controller._queueTotalSize-=bytesToCopy,pullIntoDescriptor.bytesFilled+=bytesToCopy,totalBytesToCopyRemaining-=bytesToCopy}return elementSize}function ReadableByteStreamControllerHandleQueueDrain(controller){0===controller._queueTotalSize&&controller._closeRequested?(ReadableByteStreamControllerClearAlgorithms(controller),ReadableStreamClose(controller._controlledReadableByteStream)):ReadableByteStreamControllerCallPullIfNeeded(controller)}function ReadableByteStreamControllerInvalidateBYOBRequest(controller){null!==controller._byobRequest&&(controller._byobRequest._associatedReadableByteStreamController=void 0,controller._byobRequest._view=null,controller._byobRequest=null)}function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller){for(;0<controller._pendingPullIntos.length;){if(0===controller._queueTotalSize)return;var pullIntoDescriptor=controller._pendingPullIntos.peek();ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller,pullIntoDescriptor)&&(ReadableByteStreamControllerShiftPendingPullInto(controller),ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream,pullIntoDescriptor))}}function ReadableByteStreamControllerRespondInternal(controller,bytesWritten){var firstDescriptor=controller._pendingPullIntos.peek();ReadableByteStreamControllerInvalidateBYOBRequest(controller),"closed"===controller._controlledReadableByteStream._state?function(controller){var stream=controller._controlledReadableByteStream;if(ReadableStreamHasBYOBReader(stream))for(;0<stream._reader._readIntoRequests.length;)ReadableByteStreamControllerCommitPullIntoDescriptor(stream,ReadableByteStreamControllerShiftPendingPullInto(controller))}(controller):function(controller,bytesWritten,pullIntoDescriptor){var end;pullIntoDescriptor.bytesFilled+=bytesWritten,pullIntoDescriptor.bytesFilled<pullIntoDescriptor.elementSize||(ReadableByteStreamControllerShiftPendingPullInto(controller),0<(bytesWritten=pullIntoDescriptor.bytesFilled%pullIntoDescriptor.elementSize)&&(end=pullIntoDescriptor.byteOffset+pullIntoDescriptor.bytesFilled,ReadableByteStreamControllerEnqueueChunkToQueue(controller,end=ArrayBufferSlice(pullIntoDescriptor.buffer,end-bytesWritten,end),0,end.byteLength)),pullIntoDescriptor.bytesFilled-=bytesWritten,ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream,pullIntoDescriptor),ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller))}(controller,bytesWritten,firstDescriptor),ReadableByteStreamControllerCallPullIfNeeded(controller)}function ReadableByteStreamControllerShiftPendingPullInto(controller){return controller._pendingPullIntos.shift()}function ReadableByteStreamControllerClearAlgorithms(controller){controller._pullAlgorithm=void 0,controller._cancelAlgorithm=void 0}function ReadableByteStreamControllerClose(controller){var e,stream=controller._controlledReadableByteStream;if(!controller._closeRequested&&"readable"===stream._state)if(0<controller._queueTotalSize)controller._closeRequested=!0;else{if(0<controller._pendingPullIntos.length)if(0<controller._pendingPullIntos.peek().bytesFilled)throw ReadableByteStreamControllerError(controller,e=new TypeError("Insufficient bytes to fill elements in the given buffer")),e;ReadableByteStreamControllerClearAlgorithms(controller),ReadableStreamClose(stream)}}function ReadableByteStreamControllerEnqueue(controller,chunk){var byteOffset,buffer,firstPendingPullInto,stream=controller._controlledReadableByteStream;controller._closeRequested||"readable"!==stream._state||(buffer=chunk.buffer,byteOffset=chunk.byteOffset,chunk=chunk.byteLength,buffer=buffer,0<controller._pendingPullIntos.length&&((firstPendingPullInto=controller._pendingPullIntos.peek()).buffer,firstPendingPullInto.buffer=firstPendingPullInto.buffer),ReadableByteStreamControllerInvalidateBYOBRequest(controller),ReadableStreamHasDefaultReader(stream)?0===stream._reader._readRequests.length?ReadableByteStreamControllerEnqueueChunkToQueue(controller,buffer,byteOffset,chunk):(0<controller._pendingPullIntos.length&&ReadableByteStreamControllerShiftPendingPullInto(controller),ReadableStreamFulfillReadRequest(stream,new Uint8Array(buffer,byteOffset,chunk),!1)):ReadableStreamHasBYOBReader(stream)?(ReadableByteStreamControllerEnqueueChunkToQueue(controller,buffer,byteOffset,chunk),ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller)):ReadableByteStreamControllerEnqueueChunkToQueue(controller,buffer,byteOffset,chunk),ReadableByteStreamControllerCallPullIfNeeded(controller))}function ReadableByteStreamControllerError(controller,e){var stream=controller._controlledReadableByteStream;"readable"===stream._state&&(ReadableByteStreamControllerClearPendingPullIntos(controller),ResetQueue(controller),ReadableByteStreamControllerClearAlgorithms(controller),ReadableStreamError(stream,e))}function ReadableByteStreamControllerGetBYOBRequest(controller){var firstDescriptor,byobRequest;return null===controller._byobRequest&&0<controller._pendingPullIntos.length&&(firstDescriptor=controller._pendingPullIntos.peek(),firstDescriptor=new Uint8Array(firstDescriptor.buffer,firstDescriptor.byteOffset+firstDescriptor.bytesFilled,firstDescriptor.byteLength-firstDescriptor.bytesFilled),function(request,controller,view){request._associatedReadableByteStreamController=controller,request._view=view}(byobRequest=Object.create(ReadableStreamBYOBRequest.prototype),controller,firstDescriptor),controller._byobRequest=byobRequest),controller._byobRequest}function ReadableByteStreamControllerGetDesiredSize(controller){var state=controller._controlledReadableByteStream._state;return"errored"===state?null:"closed"===state?0:controller._strategyHWM-controller._queueTotalSize}function ReadableByteStreamControllerRespond(controller,bytesWritten){var firstDescriptor=controller._pendingPullIntos.peek();if("closed"===controller._controlledReadableByteStream._state){if(0!==bytesWritten)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}else{if(0===bytesWritten)throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");if(firstDescriptor.bytesFilled+bytesWritten>firstDescriptor.byteLength)throw new RangeError("bytesWritten out of range")}firstDescriptor.buffer=firstDescriptor.buffer,ReadableByteStreamControllerRespondInternal(controller,bytesWritten)}function ReadableByteStreamControllerRespondWithNewView(controller,view){var firstDescriptor=controller._pendingPullIntos.peek();if("closed"===controller._controlledReadableByteStream._state){if(0!==view.byteLength)throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream")}else if(0===view.byteLength)throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");if(firstDescriptor.byteOffset+firstDescriptor.bytesFilled!==view.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(firstDescriptor.bufferByteLength!==view.buffer.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");if(firstDescriptor.bytesFilled+view.byteLength>firstDescriptor.byteLength)throw new RangeError("The region specified by view is larger than byobRequest");var viewByteLength=view.byteLength;firstDescriptor.buffer=view.buffer,ReadableByteStreamControllerRespondInternal(controller,viewByteLength)}function SetUpReadableByteStreamController(stream,controller,startAlgorithm,pullAlgorithm,cancelAlgorithm,highWaterMark,autoAllocateChunkSize){controller._controlledReadableByteStream=stream,controller._pullAgain=!1,controller._pulling=!1,controller._byobRequest=null,controller._queue=controller._queueTotalSize=void 0,ResetQueue(controller),controller._closeRequested=!1,controller._started=!1,controller._strategyHWM=highWaterMark,controller._pullAlgorithm=pullAlgorithm,controller._cancelAlgorithm=cancelAlgorithm,controller._autoAllocateChunkSize=autoAllocateChunkSize,controller._pendingPullIntos=new SimpleQueue,stream._readableStreamController=controller,uponPromise(promiseResolvedWith(startAlgorithm()),()=>{controller._started=!0,ReadableByteStreamControllerCallPullIfNeeded(controller)},r=>{ReadableByteStreamControllerError(controller,r)})}function byobRequestBrandCheckException(name){return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`)}function byteStreamControllerBrandCheckException(name){return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`)}function AcquireReadableStreamBYOBReader(stream){return new ReadableStreamBYOBReader(stream)}function ReadableStreamAddReadIntoRequest(stream,readIntoRequest){stream._reader._readIntoRequests.push(readIntoRequest)}function ReadableStreamHasBYOBReader(stream){stream=stream._reader;return void 0!==stream&&!!IsReadableStreamBYOBReader(stream)}Object.defineProperties(ReadableByteStreamController.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof SymbolPolyfill.toStringTag&&Object.defineProperty(ReadableByteStreamController.prototype,SymbolPolyfill.toStringTag,{value:"ReadableByteStreamController",configurable:!0});class ReadableStreamBYOBReader{constructor(stream){if(assertRequiredArgument(stream,1,"ReadableStreamBYOBReader"),assertReadableStream(stream,"First parameter"),IsReadableStreamLocked(stream))throw new TypeError("This stream has already been locked for exclusive reading by another reader");if(!IsReadableByteStreamController(stream._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");ReadableStreamReaderGenericInitialize(this,stream),this._readIntoRequests=new SimpleQueue}get closed(){return IsReadableStreamBYOBReader(this)?this._closedPromise:promiseRejectedWith(byobReaderBrandCheckException("closed"))}cancel(reason=void 0){return IsReadableStreamBYOBReader(this)?void 0===this._ownerReadableStream?promiseRejectedWith(readerLockException("cancel")):ReadableStreamReaderGenericCancel(this,reason):promiseRejectedWith(byobReaderBrandCheckException("cancel"))}read(view){var resolvePromise,rejectPromise,promise;return IsReadableStreamBYOBReader(this)?ArrayBuffer.isView(view)?0===view.byteLength?promiseRejectedWith(new TypeError("view must have non-zero byteLength")):0===view.buffer.byteLength?promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength")):(view.buffer,void 0===this._ownerReadableStream?promiseRejectedWith(readerLockException("read from")):(promise=newPromise((resolve,reject)=>{resolvePromise=resolve,rejectPromise=reject}),ReadableStreamBYOBReaderRead(this,view,{_chunkSteps:chunk=>resolvePromise({value:chunk,done:!1}),_closeSteps:chunk=>resolvePromise({value:chunk,done:!0}),_errorSteps:e=>rejectPromise(e)}),promise)):promiseRejectedWith(new TypeError("view must be an array buffer view")):promiseRejectedWith(byobReaderBrandCheckException("read"))}releaseLock(){if(!IsReadableStreamBYOBReader(this))throw byobReaderBrandCheckException("releaseLock");if(void 0!==this._ownerReadableStream){if(0<this._readIntoRequests.length)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");ReadableStreamReaderGenericRelease(this)}}}function IsReadableStreamBYOBReader(x){return typeIsObject(x)&&Object.prototype.hasOwnProperty.call(x,"_readIntoRequests")&&x instanceof ReadableStreamBYOBReader}function ReadableStreamBYOBReaderRead(reader,view,readIntoRequest){reader=reader._ownerReadableStream;reader._disturbed=!0,"errored"===reader._state?readIntoRequest._errorSteps(reader._storedError):function(controller,view,readIntoRequest){var stream=controller._controlledReadableByteStream,elementSize=1,ctor=(view.constructor!==DataView&&(elementSize=view.constructor.BYTES_PER_ELEMENT),view.constructor),buffer={buffer:buffer=view.buffer,bufferByteLength:buffer.byteLength,byteOffset:view.byteOffset,byteLength:view.byteLength,bytesFilled:0,elementSize:elementSize,viewConstructor:ctor,readerType:"byob"};if(0<controller._pendingPullIntos.length)controller._pendingPullIntos.push(buffer),ReadableStreamAddReadIntoRequest(stream,readIntoRequest);else if("closed"===stream._state)view=new ctor(buffer.buffer,buffer.byteOffset,0),readIntoRequest._closeSteps(view);else{if(0<controller._queueTotalSize){if(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller,buffer))return elementSize=ReadableByteStreamControllerConvertPullIntoDescriptor(buffer),ReadableByteStreamControllerHandleQueueDrain(controller),readIntoRequest._chunkSteps(elementSize);if(controller._closeRequested)return ReadableByteStreamControllerError(controller,ctor=new TypeError("Insufficient bytes to fill elements in the given buffer")),readIntoRequest._errorSteps(ctor)}controller._pendingPullIntos.push(buffer),ReadableStreamAddReadIntoRequest(stream,readIntoRequest),ReadableByteStreamControllerCallPullIfNeeded(controller)}}(reader._readableStreamController,view,readIntoRequest)}function byobReaderBrandCheckException(name){return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`)}function ExtractHighWaterMark(strategy,defaultHWM){strategy=strategy.highWaterMark;if(void 0===strategy)return defaultHWM;if(NumberIsNaN(strategy)||strategy<0)throw new RangeError("Invalid highWaterMark");return strategy}function ExtractSizeAlgorithm(strategy){strategy=strategy.size;return strategy||(()=>1)}function convertQueuingStrategy(init,context){assertDictionary(init,context);var highWaterMark=null==init?void 0:init.highWaterMark,init=null==init?void 0:init.size;return{highWaterMark:void 0===highWaterMark?void 0:convertUnrestrictedDouble(highWaterMark),size:void 0===init?void 0:function(fn,context){return assertFunction(fn,context),chunk=>convertUnrestrictedDouble(fn(chunk))}(init,context+" has member 'size' that")}}function convertUnderlyingSink(original,context){assertDictionary(original,context);var abort=null==original?void 0:original.abort,close=null==original?void 0:original.close,start=null==original?void 0:original.start,type=null==original?void 0:original.type,write=null==original?void 0:original.write;return{abort:void 0===abort?void 0:function(fn,original,context){return assertFunction(fn,context),reason=>promiseCall(fn,original,[reason])}(abort,original,context+" has member 'abort' that"),close:void 0===close?void 0:function(fn,original,context){return assertFunction(fn,context),()=>promiseCall(fn,original,[])}(close,original,context+" has member 'close' that"),start:void 0===start?void 0:function(fn,original,context){return assertFunction(fn,context),controller=>reflectCall(fn,original,[controller])}(start,original,context+" has member 'start' that"),write:void 0===write?void 0:function(fn,original,context){return assertFunction(fn,context),(chunk,controller)=>promiseCall(fn,original,[chunk,controller])}(write,original,context+" has member 'write' that"),type:type}}function assertWritableStream(x,context){if(!IsWritableStream(x))throw new TypeError(context+" is not a WritableStream.")}Object.defineProperties(ReadableStreamBYOBReader.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),"symbol"==typeof SymbolPolyfill.toStringTag&&Object.defineProperty(ReadableStreamBYOBReader.prototype,SymbolPolyfill.toStringTag,{value:"ReadableStreamBYOBReader",configurable:!0});var supportsAbortController="function"==typeof AbortController;class WritableStream{constructor(rawUnderlyingSink={},rawStrategy={}){void 0===rawUnderlyingSink?rawUnderlyingSink=null:assertObject(rawUnderlyingSink,"First parameter");rawStrategy=convertQueuingStrategy(rawStrategy,"Second parameter"),rawUnderlyingSink=convertUnderlyingSink(rawUnderlyingSink,"First parameter");if(InitializeWritableStream(this),void 0!==rawUnderlyingSink.type)throw new RangeError("Invalid type is specified");var sizeAlgorithm=ExtractSizeAlgorithm(rawStrategy);!function(stream,underlyingSink,highWaterMark,sizeAlgorithm){var controller=Object.create(WritableStreamDefaultController.prototype),startAlgorithm=()=>{},writeAlgorithm=()=>promiseResolvedWith(void 0),closeAlgorithm=()=>promiseResolvedWith(void 0),abortAlgorithm=()=>promiseResolvedWith(void 0);void 0!==underlyingSink.start&&(startAlgorithm=()=>underlyingSink.start(controller));void 0!==underlyingSink.write&&(writeAlgorithm=chunk=>underlyingSink.write(chunk,controller));void 0!==underlyingSink.close&&(closeAlgorithm=()=>underlyingSink.close());void 0!==underlyingSink.abort&&(abortAlgorithm=reason=>underlyingSink.abort(reason));SetUpWritableStreamDefaultController(stream,controller,startAlgorithm,writeAlgorithm,closeAlgorithm,abortAlgorithm,highWaterMark,sizeAlgorithm)}(this,rawUnderlyingSink,ExtractHighWaterMark(rawStrategy,1),sizeAlgorithm)}get locked(){if(IsWritableStream(this))return IsWritableStreamLocked(this);throw streamBrandCheckException$2("locked")}abort(reason=void 0){return IsWritableStream(this)?IsWritableStreamLocked(this)?promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer")):WritableStreamAbort(this,reason):promiseRejectedWith(streamBrandCheckException$2("abort"))}close(){return IsWritableStream(this)?IsWritableStreamLocked(this)?promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer")):WritableStreamCloseQueuedOrInFlight(this)?promiseRejectedWith(new TypeError("Cannot close an already-closing stream")):WritableStreamClose(this):promiseRejectedWith(streamBrandCheckException$2("close"))}getWriter(){if(IsWritableStream(this))return AcquireWritableStreamDefaultWriter(this);throw streamBrandCheckException$2("getWriter")}}function AcquireWritableStreamDefaultWriter(stream){return new WritableStreamDefaultWriter(stream)}function InitializeWritableStream(stream){stream._state="writable",stream._storedError=void 0,stream._writer=void 0,stream._writableStreamController=void 0,stream._writeRequests=new SimpleQueue,stream._inFlightWriteRequest=void 0,stream._closeRequest=void 0,stream._inFlightCloseRequest=void 0,stream._pendingAbortRequest=void 0,stream._backpressure=!1}function IsWritableStream(x){return typeIsObject(x)&&Object.prototype.hasOwnProperty.call(x,"_writableStreamController")&&x instanceof WritableStream}function IsWritableStreamLocked(stream){return void 0!==stream._writer}function WritableStreamAbort(stream,reason){if("closed"===stream._state||"errored"===stream._state)return promiseResolvedWith(void 0);stream._writableStreamController._abortReason=reason,null!=(_a=stream._writableStreamController._abortController)&&_a.abort();var wasAlreadyErroring,_a=stream._state;return"closed"===_a||"errored"===_a?promiseResolvedWith(void 0):void 0!==stream._pendingAbortRequest?stream._pendingAbortRequest._promise:(wasAlreadyErroring=!1,"erroring"===_a&&(wasAlreadyErroring=!0,reason=void 0),_a=newPromise((resolve,reject)=>{stream._pendingAbortRequest={_promise:void 0,_resolve:resolve,_reject:reject,_reason:reason,_wasAlreadyErroring:wasAlreadyErroring}}),stream._pendingAbortRequest._promise=_a,wasAlreadyErroring||WritableStreamStartErroring(stream,reason),_a)}function WritableStreamClose(stream){var promise,writer,state=stream._state;return"closed"===state||"errored"===state?promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`)):(promise=newPromise((resolve,reject)=>{stream._closeRequest={_resolve:resolve,_reject:reject}}),void 0!==(writer=stream._writer)&&stream._backpressure&&"writable"===state&&defaultWriterReadyPromiseResolve(writer),EnqueueValueWithSize(state=stream._writableStreamController,closeSentinel,0),WritableStreamDefaultControllerAdvanceQueueIfNeeded(state),promise)}function WritableStreamDealWithRejection(stream,error){"writable"===stream._state?WritableStreamStartErroring(stream,error):WritableStreamFinishErroring(stream)}function WritableStreamStartErroring(stream,reason){var controller=stream._writableStreamController,writer=(stream._state="erroring",stream._storedError=reason,stream._writer);void 0!==writer&&WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer,reason),!function(stream){return void 0!==stream._inFlightWriteRequest||void 0!==stream._inFlightCloseRequest}(stream)&&controller._started&&WritableStreamFinishErroring(stream)}function WritableStreamFinishErroring(stream){stream._state="errored",stream._writableStreamController[ErrorSteps]();var abortRequest,storedError=stream._storedError;stream._writeRequests.forEach(writeRequest=>{writeRequest._reject(storedError)}),stream._writeRequests=new SimpleQueue,void 0===stream._pendingAbortRequest?WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream):(abortRequest=stream._pendingAbortRequest,stream._pendingAbortRequest=void 0,abortRequest._wasAlreadyErroring?(abortRequest._reject(storedError),WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream)):uponPromise(stream._writableStreamController[AbortSteps](abortRequest._reason),()=>{abortRequest._resolve(),WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream)},reason=>{abortRequest._reject(reason),WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream)}))}function WritableStreamCloseQueuedOrInFlight(stream){return void 0!==stream._closeRequest||void 0!==stream._inFlightCloseRequest}function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream){void 0!==stream._closeRequest&&(stream._closeRequest._reject(stream._storedError),stream._closeRequest=void 0);var writer=stream._writer;void 0!==writer&&defaultWriterClosedPromiseReject(writer,stream._storedError)}function WritableStreamUpdateBackpressure(stream,backpressure){var writer=stream._writer;void 0!==writer&&backpressure!==stream._backpressure&&(backpressure?function(writer){defaultWriterReadyPromiseInitialize(writer)}:defaultWriterReadyPromiseResolve)(writer),stream._backpressure=backpressure}Object.defineProperties(WritableStream.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),"symbol"==typeof SymbolPolyfill.toStringTag&&Object.defineProperty(WritableStream.prototype,SymbolPolyfill.toStringTag,{value:"WritableStream",configurable:!0});class WritableStreamDefaultWriter{constructor(stream){if(assertRequiredArgument(stream,1,"WritableStreamDefaultWriter"),assertWritableStream(stream,"First parameter"),void 0!==stream._writer)throw new TypeError("This stream has already been locked for exclusive writing by another writer");(this._ownerWritableStream=stream)._writer=this;var state=stream._state;"writable"===state?((!WritableStreamCloseQueuedOrInFlight(stream)&&stream._backpressure?defaultWriterReadyPromiseInitialize:defaultWriterReadyPromiseInitializeAsResolved)(this),defaultWriterClosedPromiseInitialize(this)):"erroring"===state?(defaultWriterReadyPromiseInitializeAsRejected(this,stream._storedError),defaultWriterClosedPromiseInitialize(this)):"closed"===state?(defaultWriterReadyPromiseInitializeAsResolved(this),defaultWriterClosedPromiseInitialize(state=this),defaultWriterClosedPromiseResolve(state)):(defaultWriterReadyPromiseInitializeAsRejected(this,state=stream._storedError),defaultWriterClosedPromiseInitializeAsRejected(this,state))}get closed(){return IsWritableStreamDefaultWriter(this)?this._closedPromise:promiseRejectedWith(defaultWriterBrandCheckException("closed"))}get desiredSize(){if(!IsWritableStreamDefaultWriter(this))throw defaultWriterBrandCheckException("desiredSize");if(void 0===this._ownerWritableStream)throw defaultWriterLockException("desiredSize");return writer=(writer=this)._ownerWritableStream,"errored"!==(state=writer._state)&&"erroring"!==state?"closed"!==state?WritableStreamDefaultControllerGetDesiredSize(writer._writableStreamController):0:null;var writer,state}get ready(){return IsWritableStreamDefaultWriter(this)?this._readyPromise:promiseRejectedWith(defaultWriterBrandCheckException("ready"))}abort(reason=void 0){return IsWritableStreamDefaultWriter(this)?void 0===this._ownerWritableStream?promiseRejectedWith(defaultWriterLockException("abort")):function(writer,reason){return WritableStreamAbort(writer._ownerWritableStream,reason)}(this,reason):promiseRejectedWith(defaultWriterBrandCheckException("abort"))}close(){var stream;return IsWritableStreamDefaultWriter(this)?void 0===(stream=this._ownerWritableStream)?promiseRejectedWith(defaultWriterLockException("close")):WritableStreamCloseQueuedOrInFlight(stream)?promiseRejectedWith(new TypeError("Cannot close an already-closing stream")):WritableStreamDefaultWriterClose(this):promiseRejectedWith(defaultWriterBrandCheckException("close"))}releaseLock(){if(!IsWritableStreamDefaultWriter(this))throw defaultWriterBrandCheckException("releaseLock");void 0!==this._ownerWritableStream&&WritableStreamDefaultWriterRelease(this)}write(chunk=void 0){return IsWritableStreamDefaultWriter(this)?void 0===this._ownerWritableStream?promiseRejectedWith(defaultWriterLockException("write to")):WritableStreamDefaultWriterWrite(this,chunk):promiseRejectedWith(defaultWriterBrandCheckException("write"))}}function IsWritableStreamDefaultWriter(x){return typeIsObject(x)&&Object.prototype.hasOwnProperty.call(x,"_ownerWritableStream")&&x instanceof WritableStreamDefaultWriter}function WritableStreamDefaultWriterClose(writer){return WritableStreamClose(writer._ownerWritableStream)}function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer,error){("pending"===writer._closedPromiseState?defaultWriterClosedPromiseReject:function(writer,reason){defaultWriterClosedPromiseInitializeAsRejected(writer,reason)})(writer,error)}function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer,error){("pending"===writer._readyPromiseState?defaultWriterReadyPromiseReject:function(writer,reason){defaultWriterReadyPromiseInitializeAsRejected(writer,reason)})(writer,error)}function WritableStreamDefaultWriterRelease(writer){var stream=writer._ownerWritableStream,releasedError=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer,releasedError),WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer,releasedError),stream._writer=void 0,writer._ownerWritableStream=void 0}function WritableStreamDefaultWriterWrite(writer,chunk){var stream=writer._ownerWritableStream,controller=stream._writableStreamController,chunkSize=function(controller,chunk){try{return controller._strategySizeAlgorithm(chunk)}catch(chunkSizeE){return WritableStreamDefaultControllerErrorIfNeeded(controller,chunkSizeE),1}}(controller,chunk);return stream!==writer._ownerWritableStream?promiseRejectedWith(defaultWriterLockException("write to")):"errored"===(writer=stream._state)?promiseRejectedWith(stream._storedError):WritableStreamCloseQueuedOrInFlight(stream)||"closed"===writer?promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to")):"erroring"===writer?promiseRejectedWith(stream._storedError):(writer=function(stream){return newPromise((resolve,reject)=>{stream._writeRequests.push({_resolve:resolve,_reject:reject})})}(stream),function(controller,chunk,chunkSize){try{EnqueueValueWithSize(controller,chunk,chunkSize)}catch(enqueueE){return WritableStreamDefaultControllerErrorIfNeeded(controller,enqueueE)}chunk=controller._controlledWritableStream;WritableStreamCloseQueuedOrInFlight(chunk)||"writable"!==chunk._state||(chunkSize=WritableStreamDefaultControllerGetBackpressure(controller),WritableStreamUpdateBackpressure(chunk,chunkSize));WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller)}(controller,chunk,chunkSize),writer)}Object.defineProperties(WritableStreamDefaultWriter.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),"symbol"==typeof SymbolPolyfill.toStringTag&&Object.defineProperty(WritableStreamDefaultWriter.prototype,SymbolPolyfill.toStringTag,{value:"WritableStreamDefaultWriter",configurable:!0});var closeSentinel={};class WritableStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get abortReason(){if(IsWritableStreamDefaultController(this))return this._abortReason;throw defaultControllerBrandCheckException$2("abortReason")}get signal(){if(!IsWritableStreamDefaultController(this))throw defaultControllerBrandCheckException$2("signal");if(void 0===this._abortController)throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");return this._abortController.signal}error(e=void 0){if(!IsWritableStreamDefaultController(this))throw defaultControllerBrandCheckException$2("error");"writable"===this._controlledWritableStream._state&&WritableStreamDefaultControllerError(this,e)}[AbortSteps](reason){reason=this._abortAlgorithm(reason);return WritableStreamDefaultControllerClearAlgorithms(this),reason}[ErrorSteps](){ResetQueue(this)}}function IsWritableStreamDefaultController(x){return typeIsObject(x)&&Object.prototype.hasOwnProperty.call(x,"_controlledWritableStream")&&x instanceof WritableStreamDefaultController}function SetUpWritableStreamDefaultController(stream,controller,startAlgorithm,writeAlgorithm,closeAlgorithm,abortAlgorithm,highWaterMark,sizeAlgorithm){((controller._controlledWritableStream=stream)._writableStreamController=controller)._queue=void 0,controller._queueTotalSize=void 0,ResetQueue(controller),controller._abortReason=void 0,controller._abortController=function(){if(supportsAbortController)return new AbortController}(),controller._started=!1,controller._strategySizeAlgorithm=sizeAlgorithm,controller._strategyHWM=highWaterMark,controller._writeAlgorithm=writeAlgorithm,controller._closeAlgorithm=closeAlgorithm,controller._abortAlgorithm=abortAlgorithm;sizeAlgorithm=WritableStreamDefaultControllerGetBackpressure(controller);WritableStreamUpdateBackpressure(stream,sizeAlgorithm),uponPromise(promiseResolvedWith(startAlgorithm()),()=>{controller._started=!0,WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller)},r=>{controller._started=!0,WritableStreamDealWithRejection(stream,r)})}function WritableStreamDefaultControllerClearAlgorithms(controller){controller._writeAlgorithm=void 0,controller._closeAlgorithm=void 0,controller._abortAlgorithm=void 0,controller._strategySizeAlgorithm=void 0}function WritableStreamDefaultControllerGetDesiredSize(controller){return controller._strategyHWM-controller._queueTotalSize}function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller){var stream=controller._controlledWritableStream;controller._started&&void 0===stream._inFlightWriteRequest&&("erroring"===stream._state?WritableStreamFinishErroring(stream):0!==controller._queue.length&&((stream=controller._queue.peek().value)===closeSentinel?function(controller){var stream=controller._controlledWritableStream,sinkClosePromise=(function(stream){stream._inFlightCloseRequest=stream._closeRequest,stream._closeRequest=void 0}(stream),DequeueValue(controller),controller._closeAlgorithm());WritableStreamDefaultControllerClearAlgorithms(controller),uponPromise(sinkClosePromise,()=>{!function(stream){stream._inFlightCloseRequest._resolve(void 0),stream._inFlightCloseRequest=void 0,"erroring"===stream._state&&(stream._storedError=void 0)!==stream._pendingAbortRequest&&(stream._pendingAbortRequest._resolve(),stream._pendingAbortRequest=void 0),stream._state="closed",void 0!==(stream=stream._writer)&&defaultWriterClosedPromiseResolve(stream)}(stream)},reason=>{!function(stream,error){stream._inFlightCloseRequest._reject(error),(stream._inFlightCloseRequest=void 0)!==stream._pendingAbortRequest&&(stream._pendingAbortRequest._reject(error),stream._pendingAbortRequest=void 0),WritableStreamDealWithRejection(stream,error)}(stream,reason)})}(controller):function(controller,chunk){var stream=controller._controlledWritableStream;(function(stream){stream._inFlightWriteRequest=stream._writeRequests.shift()})(stream),uponPromise(controller._writeAlgorithm(chunk),()=>{!function(stream){stream._inFlightWriteRequest._resolve(void 0),stream._inFlightWriteRequest=void 0}(stream);var state=stream._state;DequeueValue(controller),WritableStreamCloseQueuedOrInFlight(stream)||"writable"!==state||(state=WritableStreamDefaultControllerGetBackpressure(controller),WritableStreamUpdateBackpressure(stream,state)),WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller)},reason=>{"writable"===stream._state&&WritableStreamDefaultControllerClearAlgorithms(controller),function(stream,error){stream._inFlightWriteRequest._reject(error),stream._inFlightWriteRequest=void 0,WritableStreamDealWithRejection(stream,error)}(stream,reason)})}(controller,stream)))}function WritableStreamDefaultControllerErrorIfNeeded(controller,error){"writable"===controller._controlledWritableStream._state&&WritableStreamDefaultControllerError(controller,error)}function WritableStreamDefaultControllerGetBackpressure(controller){return WritableStreamDefaultControllerGetDesiredSize(controller)<=0}function WritableStreamDefaultControllerError(controller,error){var stream=controller._controlledWritableStream;WritableStreamDefaultControllerClearAlgorithms(controller),WritableStreamStartErroring(stream,error)}function streamBrandCheckException$2(name){return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`)}function defaultControllerBrandCheckException$2(name){return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`)}function defaultWriterBrandCheckException(name){return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`)}function defaultWriterLockException(name){return new TypeError("Cannot "+name+" a stream using a released writer")}function defaultWriterClosedPromiseInitialize(writer){writer._closedPromise=newPromise((resolve,reject)=>{writer._closedPromise_resolve=resolve,writer._closedPromise_reject=reject,writer._closedPromiseState="pending"})}function defaultWriterClosedPromiseInitializeAsRejected(writer,reason){defaultWriterClosedPromiseInitialize(writer),defaultWriterClosedPromiseReject(writer,reason)}function defaultWriterClosedPromiseReject(writer,reason){void 0!==writer._closedPromise_reject&&(setPromiseIsHandledToTrue(writer._closedPromise),writer._closedPromise_reject(reason),writer._closedPromise_resolve=void 0,writer._closedPromise_reject=void 0,writer._closedPromiseState="rejected")}function defaultWriterClosedPromiseResolve(writer){void 0!==writer._closedPromise_resolve&&(writer._closedPromise_resolve(void 0),writer._closedPromise_resolve=void 0,writer._closedPromise_reject=void 0,writer._closedPromiseState="resolved")}function defaultWriterReadyPromiseInitialize(writer){writer._readyPromise=newPromise((resolve,reject)=>{writer._readyPromise_resolve=resolve,writer._readyPromise_reject=reject}),writer._readyPromiseState="pending"}function defaultWriterReadyPromiseInitializeAsRejected(writer,reason){defaultWriterReadyPromiseInitialize(writer),defaultWriterReadyPromiseReject(writer,reason)}function defaultWriterReadyPromiseInitializeAsResolved(writer){defaultWriterReadyPromiseInitialize(writer),defaultWriterReadyPromiseResolve(writer)}function defaultWriterReadyPromiseReject(writer,reason){void 0!==writer._readyPromise_reject&&(setPromiseIsHandledToTrue(writer._readyPromise),writer._readyPromise_reject(reason),writer._readyPromise_resolve=void 0,writer._readyPromise_reject=void 0,writer._readyPromiseState="rejected")}function defaultWriterReadyPromiseResolve(writer){void 0!==writer._readyPromise_resolve&&(writer._readyPromise_resolve(void 0),writer._readyPromise_resolve=void 0,writer._readyPromise_reject=void 0,writer._readyPromiseState="fulfilled")}Object.defineProperties(WritableStreamDefaultController.prototype,{abortReason:{enumerable:!0},signal:{enumerable:!0},error:{enumerable:!0}}),"symbol"==typeof SymbolPolyfill.toStringTag&&Object.defineProperty(WritableStreamDefaultController.prototype,SymbolPolyfill.toStringTag,{value:"WritableStreamDefaultController",configurable:!0});globals="undefined"!=typeof DOMException?DOMException:void 0;var DOMException$1=function(ctor){if("function"==typeof ctor||"object"==typeof ctor)try{return new ctor,1}catch(_a){}}(globals)?globals:(ctor.prototype=Object.create(Error.prototype),Object.defineProperty(ctor.prototype,"constructor",{value:ctor,writable:!0,configurable:!0}),ctor);function ctor(message,name){this.message=message||"",this.name=name||"Error",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}function ReadableStreamPipeTo(source,dest,preventClose,preventAbort,preventCancel,signal){var reader=AcquireReadableStreamDefaultReader(source),writer=AcquireWritableStreamDefaultWriter(dest),shuttingDown=!(source._disturbed=!0),currentWrite=promiseResolvedWith(void 0);return newPromise((resolve,reject)=>{var abortAlgorithm,promise,action,destClosed;if(void 0!==signal){if(abortAlgorithm=()=>{var error=new DOMException$1("Aborted","AbortError"),actions=[];preventAbort||actions.push(()=>"writable"===dest._state?WritableStreamAbort(dest,error):promiseResolvedWith(void 0)),preventCancel||actions.push(()=>"readable"===source._state?ReadableStreamCancel(source,error):promiseResolvedWith(void 0)),shutdownWithAction(()=>Promise.all(actions.map(action=>action())),!0,error)},signal.aborted)return void abortAlgorithm();signal.addEventListener("abort",abortAlgorithm)}function waitForWritesToFinish(){var oldCurrentWrite=currentWrite;return PerformPromiseThen(currentWrite,()=>oldCurrentWrite!==currentWrite?waitForWritesToFinish():void 0)}function isOrBecomesErrored(stream,promise,action){"errored"===stream._state?action(stream._storedError):uponRejection(promise,action)}function shutdownWithAction(action,originalIsError,originalError){function doTheRest(){uponPromise(action(),()=>finalize(originalIsError,originalError),newError=>finalize(!0,newError))}shuttingDown||(shuttingDown=!0,"writable"!==dest._state||WritableStreamCloseQueuedOrInFlight(dest)?doTheRest():uponFulfillment(waitForWritesToFinish(),doTheRest))}function shutdown(isError,error){shuttingDown||(shuttingDown=!0,"writable"!==dest._state||WritableStreamCloseQueuedOrInFlight(dest)?finalize(isError,error):uponFulfillment(waitForWritesToFinish(),()=>finalize(isError,error)))}function finalize(isError,error){WritableStreamDefaultWriterRelease(writer),ReadableStreamReaderGenericRelease(reader),void 0!==signal&&signal.removeEventListener("abort",abortAlgorithm),isError?reject(error):resolve(void 0)}isOrBecomesErrored(source,reader._closedPromise,storedError=>{preventAbort?shutdown(!0,storedError):shutdownWithAction(()=>WritableStreamAbort(dest,storedError),!0,storedError)}),isOrBecomesErrored(dest,writer._closedPromise,storedError=>{preventCancel?shutdown(!0,storedError):shutdownWithAction(()=>ReadableStreamCancel(source,storedError),!0,storedError)}),promise=reader._closedPromise,action=()=>{preventClose?shutdown():shutdownWithAction(()=>function(writer){var stream=writer._ownerWritableStream,state=stream._state;return WritableStreamCloseQueuedOrInFlight(stream)||"closed"===state?promiseResolvedWith(void 0):"errored"===state?promiseRejectedWith(stream._storedError):WritableStreamDefaultWriterClose(writer)}(writer))},"closed"===source._state?action():uponFulfillment(promise,action),!WritableStreamCloseQueuedOrInFlight(dest)&&"closed"!==dest._state||(destClosed=new TypeError("the destination writable stream closed before all data could be piped to it"),preventCancel?shutdown(!0,destClosed):shutdownWithAction(()=>ReadableStreamCancel(source,destClosed),!0,destClosed)),setPromiseIsHandledToTrue(newPromise((resolveLoop,rejectLoop)=>{!function next(done){done?resolveLoop():PerformPromiseThen(shuttingDown?promiseResolvedWith(!0):PerformPromiseThen(writer._readyPromise,()=>newPromise((resolveRead,rejectRead)=>{ReadableStreamDefaultReaderRead(reader,{_chunkSteps:chunk=>{currentWrite=PerformPromiseThen(WritableStreamDefaultWriterWrite(writer,chunk),void 0,noop),resolveRead(!1)},_closeSteps:()=>resolveRead(!0),_errorSteps:rejectRead})})),next,rejectLoop)}(!1)}))})}class ReadableStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(IsReadableStreamDefaultController(this))return ReadableStreamDefaultControllerGetDesiredSize(this);throw defaultControllerBrandCheckException$1("desiredSize")}close(){if(!IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException$1("close");if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(this))throw new TypeError("The stream is not in a state that permits close");ReadableStreamDefaultControllerClose(this)}enqueue(chunk=void 0){if(!IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException$1("enqueue");if(ReadableStreamDefaultControllerCanCloseOrEnqueue(this))return ReadableStreamDefaultControllerEnqueue(this,chunk);throw new TypeError("The stream is not in a state that permits enqueue")}error(e=void 0){if(!IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException$1("error");ReadableStreamDefaultControllerError(this,e)}[CancelSteps](reason){ResetQueue(this);reason=this._cancelAlgorithm(reason);return ReadableStreamDefaultControllerClearAlgorithms(this),reason}[PullSteps](readRequest){var chunk,stream=this._controlledReadableStream;0<this._queue.length?(chunk=DequeueValue(this),this._closeRequested&&0===this._queue.length?(ReadableStreamDefaultControllerClearAlgorithms(this),ReadableStreamClose(stream)):ReadableStreamDefaultControllerCallPullIfNeeded(this),readRequest._chunkSteps(chunk)):(ReadableStreamAddReadRequest(stream,readRequest),ReadableStreamDefaultControllerCallPullIfNeeded(this))}}function IsReadableStreamDefaultController(x){return typeIsObject(x)&&Object.prototype.hasOwnProperty.call(x,"_controlledReadableStream")&&x instanceof ReadableStreamDefaultController}function ReadableStreamDefaultControllerCallPullIfNeeded(controller){ReadableStreamDefaultControllerShouldCallPull(controller)&&(controller._pulling?controller._pullAgain=!0:(controller._pulling=!0,uponPromise(controller._pullAlgorithm(),()=>{controller._pulling=!1,controller._pullAgain&&(controller._pullAgain=!1,ReadableStreamDefaultControllerCallPullIfNeeded(controller))},e=>{ReadableStreamDefaultControllerError(controller,e)})))}function ReadableStreamDefaultControllerShouldCallPull(controller){var stream=controller._controlledReadableStream;return!!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)&&!!controller._started&&(!!(IsReadableStreamLocked(stream)&&0<stream._reader._readRequests.length)||0<ReadableStreamDefaultControllerGetDesiredSize(controller))}function ReadableStreamDefaultControllerClearAlgorithms(controller){controller._pullAlgorithm=void 0,controller._cancelAlgorithm=void 0,controller._strategySizeAlgorithm=void 0}function ReadableStreamDefaultControllerClose(controller){var stream;ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)&&(stream=controller._controlledReadableStream,controller._closeRequested=!0,0===controller._queue.length)&&(ReadableStreamDefaultControllerClearAlgorithms(controller),ReadableStreamClose(stream))}function ReadableStreamDefaultControllerEnqueue(controller,chunk){if(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)){var chunkSize,stream=controller._controlledReadableStream;if(IsReadableStreamLocked(stream)&&0<stream._reader._readRequests.length)ReadableStreamFulfillReadRequest(stream,chunk,!1);else{try{chunkSize=controller._strategySizeAlgorithm(chunk)}catch(chunkSizeE){throw ReadableStreamDefaultControllerError(controller,chunkSizeE),chunkSizeE}try{EnqueueValueWithSize(controller,chunk,chunkSize)}catch(enqueueE){throw ReadableStreamDefaultControllerError(controller,enqueueE),enqueueE}}ReadableStreamDefaultControllerCallPullIfNeeded(controller)}}function ReadableStreamDefaultControllerError(controller,e){var stream=controller._controlledReadableStream;"readable"===stream._state&&(ResetQueue(controller),ReadableStreamDefaultControllerClearAlgorithms(controller),ReadableStreamError(stream,e))}function ReadableStreamDefaultControllerGetDesiredSize(controller){var state=controller._controlledReadableStream._state;return"errored"===state?null:"closed"===state?0:controller._strategyHWM-controller._queueTotalSize}function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller){var state=controller._controlledReadableStream._state;return!controller._closeRequested&&"readable"===state}function SetUpReadableStreamDefaultController(stream,controller,startAlgorithm,pullAlgorithm,cancelAlgorithm,highWaterMark,sizeAlgorithm){controller._controlledReadableStream=stream,controller._queue=void 0,controller._queueTotalSize=void 0,ResetQueue(controller),controller._started=!1,controller._closeRequested=!1,controller._pullAgain=!1,controller._pulling=!1,controller._strategySizeAlgorithm=sizeAlgorithm,controller._strategyHWM=highWaterMark,controller._pullAlgorithm=pullAlgorithm,controller._cancelAlgorithm=cancelAlgorithm,stream._readableStreamController=controller,uponPromise(promiseResolvedWith(startAlgorithm()),()=>{controller._started=!0,ReadableStreamDefaultControllerCallPullIfNeeded(controller)},r=>{ReadableStreamDefaultControllerError(controller,r)})}function defaultControllerBrandCheckException$1(name){return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`)}function ReadableStreamTee(stream){return(IsReadableByteStreamController(stream._readableStreamController)?function(stream){var reason1,reason2,branch1,branch2,resolveCancelPromise,reader=AcquireReadableStreamDefaultReader(stream),reading=!1,readAgainForBranch1=!1,readAgainForBranch2=!1,canceled1=!1,canceled2=!1,cancelPromise=newPromise(resolve=>{resolveCancelPromise=resolve});function forwardReaderError(thisReader){uponRejection(thisReader._closedPromise,r=>{thisReader!==reader||(ReadableByteStreamControllerError(branch1._readableStreamController,r),ReadableByteStreamControllerError(branch2._readableStreamController,r),canceled1&&canceled2)||resolveCancelPromise(void 0)})}function pullWithDefaultReader(){IsReadableStreamBYOBReader(reader)&&(ReadableStreamReaderGenericRelease(reader),forwardReaderError(reader=AcquireReadableStreamDefaultReader(stream))),ReadableStreamDefaultReaderRead(reader,{_chunkSteps:chunk=>{queueMicrotask(()=>{readAgainForBranch2=readAgainForBranch1=!1;var chunk1=chunk,chunk2=chunk;if(!canceled1&&!canceled2)try{chunk2=CloneAsUint8Array(chunk)}catch(cloneE){return ReadableByteStreamControllerError(branch1._readableStreamController,cloneE),ReadableByteStreamControllerError(branch2._readableStreamController,cloneE),void resolveCancelPromise(ReadableStreamCancel(stream,cloneE))}canceled1||ReadableByteStreamControllerEnqueue(branch1._readableStreamController,chunk1),canceled2||ReadableByteStreamControllerEnqueue(branch2._readableStreamController,chunk2),reading=!1,readAgainForBranch1?pull1Algorithm():readAgainForBranch2&&pull2Algorithm()})},_closeSteps:()=>{reading=!1,canceled1||ReadableByteStreamControllerClose(branch1._readableStreamController),canceled2||ReadableByteStreamControllerClose(branch2._readableStreamController),0<branch1._readableStreamController._pendingPullIntos.length&&ReadableByteStreamControllerRespond(branch1._readableStreamController,0),0<branch2._readableStreamController._pendingPullIntos.length&&ReadableByteStreamControllerRespond(branch2._readableStreamController,0),canceled1&&canceled2||resolveCancelPromise(void 0)},_errorSteps:()=>{reading=!1}})}function pullWithBYOBReader(view,forBranch2){IsReadableStreamDefaultReader(reader)&&(ReadableStreamReaderGenericRelease(reader),forwardReaderError(reader=AcquireReadableStreamBYOBReader(stream)));var byobBranch=forBranch2?branch2:branch1,otherBranch=forBranch2?branch1:branch2;ReadableStreamBYOBReaderRead(reader,view,{_chunkSteps:chunk=>{queueMicrotask(()=>{readAgainForBranch2=readAgainForBranch1=!1;var clonedChunk,byobCanceled=forBranch2?canceled2:canceled1;if(forBranch2?canceled1:canceled2)byobCanceled||ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController,chunk);else{try{clonedChunk=CloneAsUint8Array(chunk)}catch(cloneE){return ReadableByteStreamControllerError(byobBranch._readableStreamController,cloneE),ReadableByteStreamControllerError(otherBranch._readableStreamController,cloneE),void resolveCancelPromise(ReadableStreamCancel(stream,cloneE))}byobCanceled||ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController,chunk),ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController,clonedChunk)}reading=!1,readAgainForBranch1?pull1Algorithm():readAgainForBranch2&&pull2Algorithm()})},_closeSteps:chunk=>{reading=!1;var byobCanceled=forBranch2?canceled2:canceled1,otherCanceled=forBranch2?canceled1:canceled2;byobCanceled||ReadableByteStreamControllerClose(byobBranch._readableStreamController),otherCanceled||ReadableByteStreamControllerClose(otherBranch._readableStreamController),void 0!==chunk&&(byobCanceled||ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController,chunk),!otherCanceled)&&0<otherBranch._readableStreamController._pendingPullIntos.length&&ReadableByteStreamControllerRespond(otherBranch._readableStreamController,0),byobCanceled&&otherCanceled||resolveCancelPromise(void 0)},_errorSteps:()=>{reading=!1}})}function pull1Algorithm(){var byobRequest;return reading?readAgainForBranch1=!0:(reading=!0,null===(byobRequest=ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController))?pullWithDefaultReader():pullWithBYOBReader(byobRequest._view,!1)),promiseResolvedWith(void 0)}function pull2Algorithm(){var byobRequest;return reading?readAgainForBranch2=!0:(reading=!0,null===(byobRequest=ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController))?pullWithDefaultReader():pullWithBYOBReader(byobRequest._view,!0)),promiseResolvedWith(void 0)}function startAlgorithm(){}return branch1=CreateReadableByteStream(startAlgorithm,pull1Algorithm,function(reason){return canceled1=!0,reason1=reason,canceled2&&(reason=[reason1,reason2].slice(),reason=ReadableStreamCancel(stream,reason),resolveCancelPromise(reason)),cancelPromise}),branch2=CreateReadableByteStream(startAlgorithm,pull2Algorithm,function(reason){return canceled2=!0,reason2=reason,canceled1&&(reason=[reason1,reason2].slice(),reason=ReadableStreamCancel(stream,reason),resolveCancelPromise(reason)),cancelPromise}),forwardReaderError(reader),[branch1,branch2]}:function(stream){var reason1,reason2,branch1,branch2,resolveCancelPromise,reader=AcquireReadableStreamDefaultReader(stream),reading=!1,readAgain=!1,canceled1=!1,canceled2=!1,cancelPromise=newPromise(resolve=>{resolveCancelPromise=resolve});function pullAlgorithm(){return reading?readAgain=!0:(reading=!0,ReadableStreamDefaultReaderRead(reader,{_chunkSteps:chunk=>{queueMicrotask(()=>{readAgain=!1;var chunk2=chunk;canceled1||ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController,chunk),canceled2||ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController,chunk2),reading=!1,readAgain&&pullAlgorithm()})},_closeSteps:()=>{reading=!1,canceled1||ReadableStreamDefaultControllerClose(branch1._readableStreamController),canceled2||ReadableStreamDefaultControllerClose(branch2._readableStreamController),canceled1&&canceled2||resolveCancelPromise(void 0)},_errorSteps:()=>{reading=!1}})),promiseResolvedWith(void 0)}function startAlgorithm(){}return branch1=CreateReadableStream(startAlgorithm,pullAlgorithm,function(reason){return canceled1=!0,reason1=reason,canceled2&&(reason=[reason1,reason2].slice(),reason=ReadableStreamCancel(stream,reason),resolveCancelPromise(reason)),cancelPromise}),branch2=CreateReadableStream(startAlgorithm,pullAlgorithm,function(reason){return canceled2=!0,reason2=reason,canceled1&&(reason=[reason1,reason2].slice(),reason=ReadableStreamCancel(stream,reason),resolveCancelPromise(reason)),cancelPromise}),uponRejection(reader._closedPromise,r=>{ReadableStreamDefaultControllerError(branch1._readableStreamController,r),ReadableStreamDefaultControllerError(branch2._readableStreamController,r),canceled1&&canceled2||resolveCancelPromise(void 0)}),[branch1,branch2]})(stream)}function convertUnderlyingDefaultOrByteSource(source,context){assertDictionary(source,context);var autoAllocateChunkSize=null==source?void 0:source.autoAllocateChunkSize,cancel=null==source?void 0:source.cancel,pull=null==source?void 0:source.pull,start=null==source?void 0:source.start,type=null==source?void 0:source.type;return{autoAllocateChunkSize:void 0===autoAllocateChunkSize?void 0:convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize,context+" has member 'autoAllocateChunkSize' that"),cancel:void 0===cancel?void 0:function(fn,original,context){return assertFunction(fn,context),reason=>promiseCall(fn,original,[reason])}(cancel,source,context+" has member 'cancel' that"),pull:void 0===pull?void 0:function(fn,original,context){return assertFunction(fn,context),controller=>promiseCall(fn,original,[controller])}(pull,source,context+" has member 'pull' that"),start:void 0===start?void 0:function(fn,original,context){return assertFunction(fn,context),controller=>reflectCall(fn,original,[controller])}(start,source,context+" has member 'start' that"),type:void 0===type?void 0:function(type,context){if("bytes"===(type=`${type}`))return type;throw new TypeError(context+` '${type}' is not a valid enumeration value for ReadableStreamType`)}(type,context+" has member 'type' that")}}function convertReaderOptions(options,context){assertDictionary(options,context);options=null==options?void 0:options.mode;return{mode:void 0===options?void 0:function(mode,context){if("byob"===(mode=`${mode}`))return mode;throw new TypeError(context+` '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`)}(options,context+" has member 'mode' that")}}function convertPipeOptions(options,context){assertDictionary(options,context);var preventAbort=null==options?void 0:options.preventAbort,preventCancel=null==options?void 0:options.preventCancel,preventClose=null==options?void 0:options.preventClose,options=null==options?void 0:options.signal;return void 0!==options&&function(signal,context){if(!function(value){if("object"==typeof value&&null!==value)try{return"boolean"==typeof value.aborted}catch(_a){}}(signal))throw new TypeError(context+" is not an AbortSignal.")}(options,context+" has member 'signal' that"),{preventAbort:Boolean(preventAbort),preventCancel:Boolean(preventCancel),preventClose:Boolean(preventClose),signal:options}}Object.defineProperties(ReadableStreamDefaultController.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof SymbolPolyfill.toStringTag&&Object.defineProperty(ReadableStreamDefaultController.prototype,SymbolPolyfill.toStringTag,{value:"ReadableStreamDefaultController",configurable:!0});class ReadableStream{constructor(rawUnderlyingSource={},rawStrategy={}){void 0===rawUnderlyingSource?rawUnderlyingSource=null:assertObject(rawUnderlyingSource,"First parameter");rawStrategy=convertQueuingStrategy(rawStrategy,"Second parameter"),rawUnderlyingSource=convertUnderlyingDefaultOrByteSource(rawUnderlyingSource,"First parameter");if(InitializeReadableStream(this),"bytes"===rawUnderlyingSource.type){if(void 0!==rawStrategy.size)throw new RangeError("The strategy for a byte stream cannot have a size function");!function(stream,underlyingByteSource,highWaterMark){var controller=Object.create(ReadableByteStreamController.prototype),startAlgorithm=()=>{},pullAlgorithm=()=>promiseResolvedWith(void 0),cancelAlgorithm=()=>promiseResolvedWith(void 0),autoAllocateChunkSize=(void 0!==underlyingByteSource.start&&(startAlgorithm=()=>underlyingByteSource.start(controller)),void 0!==underlyingByteSource.pull&&(pullAlgorithm=()=>underlyingByteSource.pull(controller)),void 0!==underlyingByteSource.cancel&&(cancelAlgorithm=reason=>underlyingByteSource.cancel(reason)),underlyingByteSource.autoAllocateChunkSize);if(0===autoAllocateChunkSize)throw new TypeError("autoAllocateChunkSize must be greater than 0");SetUpReadableByteStreamController(stream,controller,startAlgorithm,pullAlgorithm,cancelAlgorithm,highWaterMark,autoAllocateChunkSize)}(this,rawUnderlyingSource,ExtractHighWaterMark(rawStrategy,0))}else{var sizeAlgorithm=ExtractSizeAlgorithm(rawStrategy);!function(stream,underlyingSource,highWaterMark,sizeAlgorithm){var controller=Object.create(ReadableStreamDefaultController.prototype),startAlgorithm=()=>{},pullAlgorithm=()=>promiseResolvedWith(void 0),cancelAlgorithm=()=>promiseResolvedWith(void 0);void 0!==underlyingSource.start&&(startAlgorithm=()=>underlyingSource.start(controller)),void 0!==underlyingSource.pull&&(pullAlgorithm=()=>underlyingSource.pull(controller)),void 0!==underlyingSource.cancel&&(cancelAlgorithm=reason=>underlyingSource.cancel(reason)),SetUpReadableStreamDefaultController(stream,controller,startAlgorithm,pullAlgorithm,cancelAlgorithm,highWaterMark,sizeAlgorithm)}(this,rawUnderlyingSource,ExtractHighWaterMark(rawStrategy,1),sizeAlgorithm)}}get locked(){if(IsReadableStream(this))return IsReadableStreamLocked(this);throw streamBrandCheckException$1("locked")}cancel(reason=void 0){return IsReadableStream(this)?IsReadableStreamLocked(this)?promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader")):ReadableStreamCancel(this,reason):promiseRejectedWith(streamBrandCheckException$1("cancel"))}getReader(rawOptions=void 0){if(IsReadableStream(this))return(void 0===convertReaderOptions(rawOptions,"First parameter").mode?AcquireReadableStreamDefaultReader:AcquireReadableStreamBYOBReader)(this);throw streamBrandCheckException$1("getReader")}pipeThrough(rawTransform,rawOptions={}){if(!IsReadableStream(this))throw streamBrandCheckException$1("pipeThrough");assertRequiredArgument(rawTransform,1,"pipeThrough");assertDictionary(rawTransform=rawTransform,context="First parameter"),assertRequiredField(readable=null==rawTransform?void 0:rawTransform.readable,"readable","ReadableWritablePair"),assertReadableStream(readable,context+" has member 'readable' that"),assertRequiredField(rawTransform=null==rawTransform?void 0:rawTransform.writable,"writable","ReadableWritablePair"),assertWritableStream(rawTransform,context+" has member 'writable' that");var context={readable:readable,writable:rawTransform},readable=convertPipeOptions(rawOptions,"Second parameter");if(IsReadableStreamLocked(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(void 0!==context.writable._writer)throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");return setPromiseIsHandledToTrue(ReadableStreamPipeTo(this,context.writable,readable.preventClose,readable.preventAbort,readable.preventCancel,readable.signal)),context.readable}pipeTo(destination,rawOptions={}){if(!IsReadableStream(this))return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));if(void 0===destination)return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");if(!IsWritableStream(destination))return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));var options;try{options=convertPipeOptions(rawOptions,"Second parameter")}catch(e){return promiseRejectedWith(e)}return IsReadableStreamLocked(this)?promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")):void 0!==destination._writer?promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")):ReadableStreamPipeTo(this,destination,options.preventClose,options.preventAbort,options.preventCancel,options.signal)}tee(){if(IsReadableStream(this))return ReadableStreamTee(this).slice();throw streamBrandCheckException$1("tee")}values(rawOptions=void 0){var stream;if(IsReadableStream(this))return rawOptions=function(options,context){return assertDictionary(options,context),context=null==options?void 0:options.preventCancel,{preventCancel:Boolean(context)}}(rawOptions,"First parameter"),stream=this,rawOptions=rawOptions.preventCancel,stream=AcquireReadableStreamDefaultReader(stream),stream=new ReadableStreamAsyncIteratorImpl(stream,rawOptions),(rawOptions=Object.create(ReadableStreamAsyncIteratorPrototype))._asyncIteratorImpl=stream,rawOptions;throw streamBrandCheckException$1("values")}}function CreateReadableStream(startAlgorithm,pullAlgorithm,cancelAlgorithm,highWaterMark=1,sizeAlgorithm=()=>1){var stream=Object.create(ReadableStream.prototype);return InitializeReadableStream(stream),SetUpReadableStreamDefaultController(stream,Object.create(ReadableStreamDefaultController.prototype),startAlgorithm,pullAlgorithm,cancelAlgorithm,highWaterMark,sizeAlgorithm),stream}function CreateReadableByteStream(startAlgorithm,pullAlgorithm,cancelAlgorithm){var stream=Object.create(ReadableStream.prototype);return InitializeReadableStream(stream),SetUpReadableByteStreamController(stream,Object.create(ReadableByteStreamController.prototype),startAlgorithm,pullAlgorithm,cancelAlgorithm,0,void 0),stream}function InitializeReadableStream(stream){stream._state="readable",stream._reader=void 0,stream._storedError=void 0,stream._disturbed=!1}function IsReadableStream(x){return typeIsObject(x)&&Object.prototype.hasOwnProperty.call(x,"_readableStreamController")&&x instanceof ReadableStream}function IsReadableStreamLocked(stream){return void 0!==stream._reader}function ReadableStreamCancel(stream,reason){if(stream._disturbed=!0,"closed"===stream._state)return promiseResolvedWith(void 0);if("errored"===stream._state)return promiseRejectedWith(stream._storedError);ReadableStreamClose(stream);var reader=stream._reader;return void 0!==reader&&IsReadableStreamBYOBReader(reader)&&(reader._readIntoRequests.forEach(readIntoRequest=>{readIntoRequest._closeSteps(void 0)}),reader._readIntoRequests=new SimpleQueue),transformPromiseWith(stream._readableStreamController[CancelSteps](reason),noop)}function ReadableStreamClose(stream){stream._state="closed";stream=stream._reader;void 0!==stream&&(defaultReaderClosedPromiseResolve(stream),IsReadableStreamDefaultReader(stream))&&(stream._readRequests.forEach(readRequest=>{readRequest._closeSteps()}),stream._readRequests=new SimpleQueue)}function ReadableStreamError(stream,e){stream._state="errored",stream._storedError=e;stream=stream._reader;void 0!==stream&&(defaultReaderClosedPromiseReject(stream,e),IsReadableStreamDefaultReader(stream)?(stream._readRequests.forEach(readRequest=>{readRequest._errorSteps(e)}),stream._readRequests=new SimpleQueue):(stream._readIntoRequests.forEach(readIntoRequest=>{readIntoRequest._errorSteps(e)}),stream._readIntoRequests=new SimpleQueue))}function streamBrandCheckException$1(name){return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`)}function convertQueuingStrategyInit(init,context){assertDictionary(init,context);context=null==init?void 0:init.highWaterMark;return assertRequiredField(context,"highWaterMark","QueuingStrategyInit"),{highWaterMark:convertUnrestrictedDouble(context)}}Object.defineProperties(ReadableStream.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),"symbol"==typeof SymbolPolyfill.toStringTag&&Object.defineProperty(ReadableStream.prototype,SymbolPolyfill.toStringTag,{value:"ReadableStream",configurable:!0}),"symbol"==typeof SymbolPolyfill.asyncIterator&&Object.defineProperty(ReadableStream.prototype,SymbolPolyfill.asyncIterator,{value:ReadableStream.prototype.values,writable:!0,configurable:!0});var byteLengthSizeFunction=chunk=>chunk.byteLength;try{Object.defineProperty(byteLengthSizeFunction,"name",{value:"size",configurable:!0})}catch(_a){}class ByteLengthQueuingStrategy{constructor(options){assertRequiredArgument(options,1,"ByteLengthQueuingStrategy"),options=convertQueuingStrategyInit(options,"First parameter"),this._byteLengthQueuingStrategyHighWaterMark=options.highWaterMark}get highWaterMark(){if(IsByteLengthQueuingStrategy(this))return this._byteLengthQueuingStrategyHighWaterMark;throw byteLengthBrandCheckException("highWaterMark")}get size(){if(IsByteLengthQueuingStrategy(this))return byteLengthSizeFunction;throw byteLengthBrandCheckException("size")}}function byteLengthBrandCheckException(name){return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`)}function IsByteLengthQueuingStrategy(x){return typeIsObject(x)&&Object.prototype.hasOwnProperty.call(x,"_byteLengthQueuingStrategyHighWaterMark")&&x instanceof ByteLengthQueuingStrategy}Object.defineProperties(ByteLengthQueuingStrategy.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),"symbol"==typeof SymbolPolyfill.toStringTag&&Object.defineProperty(ByteLengthQueuingStrategy.prototype,SymbolPolyfill.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:!0});var countSizeFunction=()=>1;try{Object.defineProperty(countSizeFunction,"name",{value:"size",configurable:!0})}catch(_a){}class CountQueuingStrategy{constructor(options){assertRequiredArgument(options,1,"CountQueuingStrategy"),options=convertQueuingStrategyInit(options,"First parameter"),this._countQueuingStrategyHighWaterMark=options.highWaterMark}get highWaterMark(){if(IsCountQueuingStrategy(this))return this._countQueuingStrategyHighWaterMark;throw countBrandCheckException("highWaterMark")}get size(){if(IsCountQueuingStrategy(this))return countSizeFunction;throw countBrandCheckException("size")}}function countBrandCheckException(name){return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`)}function IsCountQueuingStrategy(x){return typeIsObject(x)&&Object.prototype.hasOwnProperty.call(x,"_countQueuingStrategyHighWaterMark")&&x instanceof CountQueuingStrategy}function convertTransformer(original,context){assertDictionary(original,context);var flush=null==original?void 0:original.flush,readableType=null==original?void 0:original.readableType,start=null==original?void 0:original.start,transform=null==original?void 0:original.transform,writableType=null==original?void 0:original.writableType;return{flush:void 0===flush?void 0:function(fn,original,context){return assertFunction(fn,context),controller=>promiseCall(fn,original,[controller])}(flush,original,context+" has member 'flush' that"),readableType:readableType,start:void 0===start?void 0:function(fn,original,context){return assertFunction(fn,context),controller=>reflectCall(fn,original,[controller])}(start,original,context+" has member 'start' that"),transform:void 0===transform?void 0:function(fn,original,context){return assertFunction(fn,context),(chunk,controller)=>promiseCall(fn,original,[chunk,controller])}(transform,original,context+" has member 'transform' that"),writableType:writableType}}Object.defineProperties(CountQueuingStrategy.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),"symbol"==typeof SymbolPolyfill.toStringTag&&Object.defineProperty(CountQueuingStrategy.prototype,SymbolPolyfill.toStringTag,{value:"CountQueuingStrategy",configurable:!0});class TransformStream{constructor(rawTransformer={},rawWritableStrategy={},rawReadableStrategy={}){void 0===rawTransformer&&(rawTransformer=null);rawWritableStrategy=convertQueuingStrategy(rawWritableStrategy,"Second parameter"),rawReadableStrategy=convertQueuingStrategy(rawReadableStrategy,"Third parameter"),rawTransformer=convertTransformer(rawTransformer,"First parameter");if(void 0!==rawTransformer.readableType)throw new RangeError("Invalid readableType specified");if(void 0!==rawTransformer.writableType)throw new RangeError("Invalid writableType specified");var startPromise_resolve,readableHighWaterMark=ExtractHighWaterMark(rawReadableStrategy,0),rawReadableStrategy=ExtractSizeAlgorithm(rawReadableStrategy),writableHighWaterMark=ExtractHighWaterMark(rawWritableStrategy,1),rawWritableStrategy=ExtractSizeAlgorithm(rawWritableStrategy);!function(stream,startPromise,writableHighWaterMark,writableSizeAlgorithm,readableHighWaterMark,readableSizeAlgorithm){function startAlgorithm(){return startPromise}stream._writable=function(startAlgorithm,writeAlgorithm,closeAlgorithm,abortAlgorithm,highWaterMark=1,sizeAlgorithm=()=>1){var stream=Object.create(WritableStream.prototype);return InitializeWritableStream(stream),SetUpWritableStreamDefaultController(stream,Object.create(WritableStreamDefaultController.prototype),startAlgorithm,writeAlgorithm,closeAlgorithm,abortAlgorithm,highWaterMark,sizeAlgorithm),stream}(startAlgorithm,function(chunk){return function(stream,chunk){var controller=stream._transformStreamController;if(stream._backpressure)return transformPromiseWith(stream._backpressureChangePromise,()=>{var writable=stream._writable;if("erroring"===writable._state)throw writable._storedError;return TransformStreamDefaultControllerPerformTransform(controller,chunk)});return TransformStreamDefaultControllerPerformTransform(controller,chunk)}(stream,chunk)},function(){return function(stream){var readable=stream._readable,controller=stream._transformStreamController,flushPromise=controller._flushAlgorithm();return TransformStreamDefaultControllerClearAlgorithms(controller),transformPromiseWith(flushPromise,()=>{if("errored"===readable._state)throw readable._storedError;ReadableStreamDefaultControllerClose(readable._readableStreamController)},r=>{throw TransformStreamError(stream,r),readable._storedError})}(stream)},function(reason){return function(stream,reason){return TransformStreamError(stream,reason),promiseResolvedWith(void 0)}(stream,reason)},writableHighWaterMark,writableSizeAlgorithm),stream._readable=CreateReadableStream(startAlgorithm,function(){return function(stream){return TransformStreamSetBackpressure(stream,!1),stream._backpressureChangePromise}(stream)},function(reason){return TransformStreamErrorWritableAndUnblockWrite(stream,reason),promiseResolvedWith(void 0)},readableHighWaterMark,readableSizeAlgorithm),stream._backpressure=void 0,stream._backpressureChangePromise=void 0,stream._backpressureChangePromise_resolve=void 0,TransformStreamSetBackpressure(stream,!0),stream._transformStreamController=void 0}(this,newPromise(resolve=>{startPromise_resolve=resolve}),writableHighWaterMark,rawWritableStrategy,readableHighWaterMark,rawReadableStrategy),function(stream,transformer){var controller=Object.create(TransformStreamDefaultController.prototype),transformAlgorithm=chunk=>{try{return TransformStreamDefaultControllerEnqueue(controller,chunk),promiseResolvedWith(void 0)}catch(transformResultE){return promiseRejectedWith(transformResultE)}},flushAlgorithm=()=>promiseResolvedWith(void 0);void 0!==transformer.transform&&(transformAlgorithm=chunk=>transformer.transform(chunk,controller));void 0!==transformer.flush&&(flushAlgorithm=()=>transformer.flush(controller));!function(stream,controller,transformAlgorithm,flushAlgorithm){((controller._controlledTransformStream=stream)._transformStreamController=controller)._transformAlgorithm=transformAlgorithm,controller._flushAlgorithm=flushAlgorithm}(stream,controller,transformAlgorithm,flushAlgorithm)}(this,rawTransformer),void 0!==rawTransformer.start?startPromise_resolve(rawTransformer.start(this._transformStreamController)):startPromise_resolve(void 0)}get readable(){if(IsTransformStream(this))return this._readable;throw streamBrandCheckException("readable")}get writable(){if(IsTransformStream(this))return this._writable;throw streamBrandCheckException("writable")}}function IsTransformStream(x){return typeIsObject(x)&&Object.prototype.hasOwnProperty.call(x,"_transformStreamController")&&x instanceof TransformStream}function TransformStreamError(stream,e){ReadableStreamDefaultControllerError(stream._readable._readableStreamController,e),TransformStreamErrorWritableAndUnblockWrite(stream,e)}function TransformStreamErrorWritableAndUnblockWrite(stream,e){TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController),WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController,e),stream._backpressure&&TransformStreamSetBackpressure(stream,!1)}function TransformStreamSetBackpressure(stream,backpressure){void 0!==stream._backpressureChangePromise&&stream._backpressureChangePromise_resolve(),stream._backpressureChangePromise=newPromise(resolve=>{stream._backpressureChangePromise_resolve=resolve}),stream._backpressure=backpressure}Object.defineProperties(TransformStream.prototype,{readable:{enumerable:!0},writable:{enumerable:!0}}),"symbol"==typeof SymbolPolyfill.toStringTag&&Object.defineProperty(TransformStream.prototype,SymbolPolyfill.toStringTag,{value:"TransformStream",configurable:!0});class TransformStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(IsTransformStreamDefaultController(this))return ReadableStreamDefaultControllerGetDesiredSize(this._controlledTransformStream._readable._readableStreamController);throw defaultControllerBrandCheckException("desiredSize")}enqueue(chunk=void 0){if(!IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("enqueue");TransformStreamDefaultControllerEnqueue(this,chunk)}error(reason=void 0){if(!IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("error");TransformStreamError(this._controlledTransformStream,reason)}terminate(){if(!IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("terminate");var controller,error;ReadableStreamDefaultControllerClose((controller=(controller=this)._controlledTransformStream)._readable._readableStreamController),error=new TypeError("TransformStream terminated"),TransformStreamErrorWritableAndUnblockWrite(controller,error)}}function IsTransformStreamDefaultController(x){return typeIsObject(x)&&Object.prototype.hasOwnProperty.call(x,"_controlledTransformStream")&&x instanceof TransformStreamDefaultController}function TransformStreamDefaultControllerClearAlgorithms(controller){controller._transformAlgorithm=void 0,controller._flushAlgorithm=void 0}function TransformStreamDefaultControllerEnqueue(controller,chunk){var controller=controller._controlledTransformStream,readableController=controller._readable._readableStreamController;if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController))throw new TypeError("Readable side is not in a state that permits enqueue");try{ReadableStreamDefaultControllerEnqueue(readableController,chunk)}catch(e){throw TransformStreamErrorWritableAndUnblockWrite(controller,e),controller._readable._storedError}(function(controller){return!ReadableStreamDefaultControllerShouldCallPull(controller)})(readableController)!==controller._backpressure&&TransformStreamSetBackpressure(controller,!0)}function TransformStreamDefaultControllerPerformTransform(controller,chunk){return transformPromiseWith(controller._transformAlgorithm(chunk),void 0,r=>{throw TransformStreamError(controller._controlledTransformStream,r),r})}function defaultControllerBrandCheckException(name){return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`)}function streamBrandCheckException(name){return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`)}Object.defineProperties(TransformStreamDefaultController.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof SymbolPolyfill.toStringTag&&Object.defineProperty(TransformStreamDefaultController.prototype,SymbolPolyfill.toStringTag,{value:"TransformStreamDefaultController",configurable:!0}),exports.ByteLengthQueuingStrategy=ByteLengthQueuingStrategy,exports.CountQueuingStrategy=CountQueuingStrategy,exports.ReadableByteStreamController=ReadableByteStreamController,exports.ReadableStream=ReadableStream,exports.ReadableStreamBYOBReader=ReadableStreamBYOBReader,exports.ReadableStreamBYOBRequest=ReadableStreamBYOBRequest,exports.ReadableStreamDefaultController=ReadableStreamDefaultController,exports.ReadableStreamDefaultReader=ReadableStreamDefaultReader,exports.TransformStream=TransformStream,exports.TransformStreamDefaultController=TransformStreamDefaultController,exports.WritableStream=WritableStream,exports.WritableStreamDefaultController=WritableStreamDefaultController,exports.WritableStreamDefaultWriter=WritableStreamDefaultWriter,Object.defineProperty(exports,"__esModule",{value:!0})});